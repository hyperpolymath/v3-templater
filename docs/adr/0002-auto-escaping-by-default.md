# ADR 0002: Auto-Escaping by Default

**Status**: Accepted

**Date**: 2024-01-15

**Decision Makers**: Security Team, Project Architecture Team

## Context

Template engines must decide how to handle potentially dangerous HTML content. The two main approaches are:

1. **Auto-escaping by default** (escape unless explicitly marked safe)
2. **Manual escaping** (escape only when explicitly requested)

This is a critical security decision affecting XSS vulnerability risk.

## Decision

v3-templater will **auto-escape all variables by default**, requiring explicit `| safe` filter to bypass escaping.

## Rationale

### Security-First Approach

**XSS (Cross-Site Scripting)** is the #1 web security vulnerability. Auto-escaping by default:

- ‚úÖ Prevents XSS by default (secure by default)
- ‚úÖ Requires explicit opt-out for unsafe content
- ‚úÖ Makes security audits easier (find all `| safe` usages)
- ‚úÖ Aligns with modern framework defaults (React, Vue, Angular)

### Developer Experience

**Default Behavior:**
```html
{{ userInput }}  <!-- Automatically escaped -->
```

**Explicit Unsafe:**
```html
{{ trustedHtml | safe }}  <!-- Intentionally unescaped -->
```

This makes the *intent* clear:
- Escaped content: "this is user data, keep it safe"
- `| safe`: "I trust this content, I know what I'm doing"

## Comparison with Other Engines

| Engine | Default Behavior | v3-templater Alignment |
|--------|------------------|------------------------|
| Jinja2 | Auto-escape | ‚úÖ Same |
| Liquid | Auto-escape | ‚úÖ Same |
| Handlebars | Auto-escape | ‚úÖ Same |
| EJS | **Manual** | ‚ùå More secure |
| Mustache | Auto-escape | ‚úÖ Same |
| Pug | Auto-escape | ‚úÖ Same |

## Implementation

### Escaping Function

```typescript
function escapeHtml(str: string): string {
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#x27;')
    .replace(/\//g, '&#x2F;');
}
```

### SafeString Class

```typescript
class SafeString {
  constructor(public value: string) {}
  toString(): string {
    return this.value;
  }
}
```

### Filter Implementation

```typescript
filters.safe = (value: any): SafeString => {
  return new SafeString(String(value));
};
```

## Consequences

### Positive

- ‚úÖ **Security**: XSS prevention by default
- ‚úÖ **Audit Trail**: Easy to find potentially unsafe code (grep for `| safe`)
- ‚úÖ **Best Practice**: Aligns with industry standards
- ‚úÖ **Trust Explicit**: Developers must explicitly trust content
- ‚úÖ **Documentation**: Security practices built into API

### Negative

- ‚ùå **Performance**: Slight overhead for escaping (mitigated by caching)
- ‚ùå **Learning Curve**: Developers must learn `| safe` filter
- ‚ùå **Migration**: Different from EJS (but documented in migration guide)

### Neutral

- üìù Need comprehensive documentation on when to use `| safe`
- üìù Should provide linting rules to catch common mistakes
- üìù Examples should demonstrate both escaped and safe usage

## Configuration Option

While auto-escaping is **strongly recommended**, we provide an opt-out:

```typescript
const template = new Template({
  autoEscape: false  // NOT RECOMMENDED
});
```

**Warnings:**
- Documentation will strongly discourage this
- Security warnings in README and docs
- Linter will warn about this configuration

## Best Practices Guide

### When to Use `| safe`

**‚úÖ Safe to use:**
- Markdown rendered to HTML (already sanitized)
- Template fragments from trusted sources
- HTML generated by your own code
- Content from CMS with built-in sanitization

**‚ùå NEVER use on:**
- Direct user input
- URL parameters
- Form data
- Cookie values
- Any untrusted source

### Double Escaping Protection

```html
<!-- This is SAFE - won't double-escape -->
{{ alreadyEscaped | safe }}  <!-- If already escaped -->

<!-- This is SAFER - will escape -->
{{ userInput }}  <!-- Always escape untrusted input -->
```

## Security Testing

We will include tests for:

1. **XSS Prevention**: Ensure `<script>` tags are escaped
2. **SafeString**: Verify `| safe` bypasses escaping
3. **Edge Cases**: Test all dangerous characters
4. **Performance**: Benchmark escaping overhead

## Related Decisions

- ADR 0001: Use TypeScript (enables `SafeString` type)
- ADR 0004: Strict mode option (catches undefined safely)
- ADR 0005: Sandboxed filter execution (defense in depth)

## Alternatives Considered

### 1. Manual Escaping (EJS-style)

**Rejected** because:
- ‚ùå Developers forget to escape
- ‚ùå Easy to introduce XSS bugs
- ‚ùå Requires security expertise from all users

### 2. Context-Aware Escaping

**Future consideration** because:
- ‚è≥ More complex to implement
- ‚è≥ Can auto-detect HTML/JS/CSS/URL contexts
- ‚è≥ Would be even more secure
- ‚è≥ Planned for v2.0

### 3. Content Security Policy Integration

**Future consideration** because:
- ‚è≥ Would provide additional defense layer
- ‚è≥ Could generate CSP headers automatically
- ‚è≥ Planned for v1.2

## References

- [OWASP XSS Prevention Cheat Sheet](https://cheatsheetsecurity.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html)
- [Jinja2 Auto-escaping](https://jinja.palletsprojects.com/en/3.0.x/api/#autoescaping)
- [Template Security Best Practices](https://github.com/Hyperpolymath/v3-templater/blob/main/SECURITY.md)

## Review Schedule

This decision is **permanent** for v1.x releases.

Future major versions may introduce context-aware escaping but will maintain auto-escaping by default.

**Next Review**: Upon security incidents or major version planning
